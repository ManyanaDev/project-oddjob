{
  "version": 3,
  "sources": ["../scripts/analytics-client.ts"],
  "sourcesContent": ["interface AnalyticsOptions {\n  endpoint?: string;\n  domain?: string;\n}\n\nclass Analytics {\n  private endpoint: string;\n  private domain: string;\n  private initialized: boolean = false;\n  private sessionStartTime: number;\n  private isTracking: boolean = false;\n\n  constructor(options: AnalyticsOptions = {}) {\n    // Default endpoint based on script src or fallback to /api/events\n    const scriptEl = document.querySelector(\n      'script[src*=\"analytics.min.js\"]',\n    ) as HTMLScriptElement;\n    const defaultEndpoint = scriptEl?.src.replace(\n      \"analytics.min.js\",\n      \"api/events\",\n    );\n\n    this.endpoint = options.endpoint || defaultEndpoint || \"/api/events\";\n    this.domain = options.domain || window.location.hostname;\n    this.sessionStartTime = Date.now();\n    this.init();\n  }\n\n  private async init(): Promise<void> {\n    if (this.initialized) return;\n\n    // Track initial pageview after a small delay to ensure page is fully loaded\n    setTimeout(() => this.trackPageView(), 100);\n\n    // Setup session end tracking\n    this.setupSessionEndTracking();\n\n    // Handle route changes for SPAs and regular navigation\n    window.addEventListener(\"popstate\", this.handleRouteChange);\n\n    // For modern browsers, detect URL changes with debounced observer\n    let lastUrl = window.location.href;\n    const observer = new MutationObserver(\n      this.debounce(() => {\n        const currentUrl = window.location.href;\n        if (currentUrl !== lastUrl) {\n          lastUrl = currentUrl;\n          this.handleRouteChange();\n        }\n      }, 1000),\n    );\n\n    // Only observe body and limit to specific changes\n    const body = document.querySelector(\"body\");\n    if (body) {\n      observer.observe(body, {\n        childList: true,\n        subtree: true,\n        attributes: false,\n        characterData: false,\n      });\n    }\n\n    this.initialized = true;\n  }\n\n  // Debounce route change handling\n  private handleRouteChange = this.debounce(async () => {\n    await this.trackPageView();\n  }, 1000);\n\n  // Add debounce utility\n  private debounce(fn: Function, delay: number) {\n    let timeoutId: NodeJS.Timeout;\n    return (...args: any[]) => {\n      clearTimeout(timeoutId);\n      timeoutId = setTimeout(() => fn(...args), delay);\n    };\n  }\n\n  private setupSessionEndTracking(): void {\n    // Track tab/window close\n    window.addEventListener(\"beforeunload\", () => {\n      this.trackSessionEnd();\n    });\n\n    // Track when user switches tabs\n    document.addEventListener(\"visibilitychange\", () => {\n      if (document.visibilityState === \"hidden\") {\n        this.trackSessionEnd();\n      }\n    });\n\n    // Backup: track when user becomes inactive\n    let inactivityTimeout: NodeJS.Timeout;\n    const resetInactivityTimeout = () => {\n      clearTimeout(inactivityTimeout);\n      inactivityTimeout = setTimeout(\n        () => {\n          this.trackSessionEnd();\n        },\n        30 * 60 * 1000,\n      ); // 30 minutes of inactivity\n    };\n\n    // Reset timeout on user activity\n    [\"mousedown\", \"keydown\", \"touchstart\", \"scroll\"].forEach((event) => {\n      window.addEventListener(event, resetInactivityTimeout, { passive: true });\n    });\n\n    resetInactivityTimeout();\n  }\n\n  private async trackSessionEnd(): Promise<void> {\n    try {\n      const sessionDuration = Date.now() - this.sessionStartTime;\n\n      // Use sendBeacon for more reliable delivery during page unload\n      const eventsUrl = new URL(this.endpoint);\n      eventsUrl.searchParams.append(\"domain\", this.domain);\n      eventsUrl.searchParams.append(\"event\", \"session_end\");\n      eventsUrl.searchParams.append(\"duration\", sessionDuration.toString());\n\n      // Fallback to sync image request\n      await this.loadPixel(eventsUrl.toString());\n    } catch (error) {\n      console.warn(\"Failed to track session end:\", error);\n      // Optionally implement retry logic here\n    }\n  }\n\n  private async loadPixel(url: string): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const pixel = new Image();\n      pixel.onload = () => {\n        pixel.remove();\n        resolve();\n      };\n      pixel.onerror = (error) => {\n        pixel.remove();\n        if (error instanceof ErrorEvent) {\n          reject(new Error(`Network error: ${error.message}`));\n        } else {\n          reject(new Error(\"Failed to load tracking pixel\"));\n        }\n      };\n      pixel.src = url;\n      pixel.style.display = \"none\";\n      document.body.appendChild(pixel);\n    });\n  }\n\n  private getUtmParams(): Record<string, string> {\n    const urlParams = new URLSearchParams(window.location.search);\n    const utmParams: Record<string, string> = {};\n    [\"source\", \"medium\", \"campaign\", \"term\", \"content\"].forEach((param) => {\n      const value = urlParams.get(`utm_${param}`);\n      if (value) utmParams[param] = value;\n    });\n\n    return utmParams;\n  }\n\n  private async trackPageView(): Promise<void> {\n    // Add a guard to prevent tracking if the previous request hasn't completed\n    if (this.isTracking) return;\n    this.isTracking = true;\n\n    try {\n      await this.retryWithBackoff(async () => {\n        const eventsUrl = new URL(this.endpoint);\n        eventsUrl.searchParams.append(\"domain\", this.domain);\n        eventsUrl.searchParams.append(\"path\", window.location.pathname);\n\n        // Only add referrer if it's from a different domain\n        const referrer = document.referrer;\n        if (referrer && !referrer.includes(window.location.hostname)) {\n          eventsUrl.searchParams.append(\"ref\", referrer);\n        }\n\n        // Add UTM parameters if they exist\n        const utmParams = this.getUtmParams();\n        Object.entries(utmParams).forEach(([key, value]) => {\n          eventsUrl.searchParams.append(`utm_${key}`, value);\n        });\n\n        await this.loadPixel(eventsUrl.toString());\n      });\n    } catch (error) {\n      // Only log if it's a final failure after retries\n      console.warn(\"Failed to track page view after retries:\", error);\n    } finally {\n      this.isTracking = false;\n    }\n  }\n\n  // Helper method for exponential backoff retry\n  private async retryWithBackoff(\n    fn: () => Promise<void>,\n    maxAttempts = 3,\n    baseDelay = 1000,\n  ): Promise<void> {\n    for (let attempt = 0; attempt < maxAttempts; attempt++) {\n      try {\n        await fn();\n        return;\n      } catch (error) {\n        if (attempt === maxAttempts - 1) throw error;\n        const delay = baseDelay * Math.pow(2, attempt);\n        await new Promise((resolve) => setTimeout(resolve, delay));\n      }\n    }\n  }\n\n  private shouldRetry(error: unknown): boolean {\n    // Improve error type checking\n    if (error instanceof Error) {\n      // Retry on network errors\n      if (error.message.includes(\"Network error\")) {\n        return true;\n      }\n    }\n    // Don't retry on other types of errors\n    return false;\n  }\n\n  // Public method to manually track page views\n  public async trackView(): Promise<void> {\n    try {\n      await this.retryWithBackoff(() => this.trackPageView());\n    } catch (error) {\n      console.warn(\"Manual page view tracking failed after retries:\", error);\n    }\n  }\n}\n\n// Create instance immediately\nconst analytics = new Analytics();\n\n// Export for advanced usage\nif (typeof window !== \"undefined\") {\n  (window as any).Analytics = Analytics;\n  (window as any).analytics = analytics;\n}\n"],
  "mappings": "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",
  "names": ["Analytics", "options", "__publicField", "__async", "scriptEl", "defaultEndpoint", "lastUrl", "observer", "currentUrl", "body", "fn", "delay", "timeoutId", "args", "inactivityTimeout", "resetInactivityTimeout", "event", "sessionDuration", "eventsUrl", "error", "url", "resolve", "reject", "pixel", "urlParams", "utmParams", "param", "value", "referrer", "key", "maxAttempts", "baseDelay", "attempt", "analytics"]
}
